name: Decompile APK and Upload to Repository

on:
  workflow_dispatch:
    inputs:
      apk_url:
        description: 'URL to download the APK'
        required: true
        type: string
      target_username:
        description: 'GitHub username where the repository will be created'
        required: true
        type: string
        # Note: Ensure only trusted users can trigger this workflow as it creates
        # repositories under the specified username using the TEST token
      quiet:
        description: 'Suppress normal output (-q/--quiet)'
        required: false
        type: boolean
        default: false
      verbose:
        description: 'Increase output verbosity (-v/--verbose)'
        required: false
        type: boolean
        default: false
      force:
        description: 'Force delete destination directory (-f/--force)'
        required: false
        type: boolean
        default: false
      jobs:
        description: 'Number of jobs to execute in parallel (-j/--jobs)'
        required: false
        type: string
        default: ''
      lib:
        description: 'Use shared library package:file, comma-separated for multiple (-l/--lib)'
        required: false
        type: string
        default: ''
      no_res:
        description: 'Do not decode resources (-r/--no-res)'
        required: false
        type: boolean
        default: false
      no_src:
        description: 'Do not decode sources (-s/--no-src)'
        required: false
        type: boolean
        default: false
      only_main_classes:
        description: 'Only disassemble main dex classes (--only-main-classes)'
        required: false
        type: boolean
        default: false
      keep_debug_info:
        description: 'Include debug info in sources (default: disabled with --no-debug-info)'
        required: false
        type: boolean
        default: false
      only_manifest:
        description: 'Only decode AndroidManifest.xml (--only-manifest)'
        required: false
        type: boolean
        default: false
      res_resolve_mode:
        description: 'Resources resolve mode: remove, dummy, or keep (--res-resolve-mode)'
        required: false
        type: choice
        options:
          - ''
          - remove
          - dummy
          - keep
        default: ''
      keep_broken_res:
        description: 'Keep broken resources (--keep-broken-res)'
        required: false
        type: boolean
        default: false
      match_original:
        description: 'Keep files closest to original (--match-original)'
        required: false
        type: boolean
        default: false
      no_assets:
        description: 'Do not decode assets (--no-assets)'
        required: false
        type: boolean
        default: false

jobs:
  decompile-and-upload:
    runs-on: ubuntu-22.04
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup zram for additional memory
        run: |
          echo "Setting up zram for compressed swap..."
          # Install zram-config if not available
          sudo apt-get update -qq
          # Configure zram to use 8GB of compressed RAM
          sudo apt install linux-modules-extra-$(uname -r) zram-tools -y
          sudo modprobe zram
          sudo sed -i 's/^#PERCENT=50/PERCENT=90/' /etc/default/zramswap
          sudo sed -i 's/^#PRIORITY=100/PRIORITY=1000/' /etc/default/zramswap
          sudo systemctl restart zramswap
          zramctl
          
      - name: Set up Java
        uses: actions/setup-java@v5
        with:
          distribution: 'zulu'
          java-version: '17'

      - name: Download apktool from latest release
        run: |
          echo "Downloading apktool.jar and script from latest release..."
          
          # Get the latest release info
          LATEST_RELEASE=$(curl -s https://api.github.com/repos/${{ github.repository }}/releases/latest)
          
          # Extract download URLs using jq for reliable JSON parsing
          JAR_URL=$(echo "$LATEST_RELEASE" | jq -r '.assets[] | select(.name | endswith(".jar")) | .browser_download_url' | head -1)
          SCRIPT_URL=$(echo "$LATEST_RELEASE" | jq -r '.assets[] | select(.name == "apktool") | .browser_download_url' | head -1)
          
          if [ -z "$JAR_URL" ] || [ -z "$SCRIPT_URL" ]; then
            echo "Error: Could not find apktool.jar or script in latest release"
            echo "JAR_URL: $JAR_URL"
            echo "SCRIPT_URL: $SCRIPT_URL"
            exit 1
          fi
          
          echo "Downloading apktool.jar from: $JAR_URL"
          echo "Downloading apktool script from: $SCRIPT_URL"
          
          # Create directory for apktool
          mkdir -p apktool-bin
          
          # Download files
          curl -L -o apktool-bin/apktool.jar "$JAR_URL"
          curl -L -o apktool-bin/apktool "$SCRIPT_URL"
          
          # Make the script executable
          chmod +x apktool-bin/apktool
          
          # Add to PATH
          echo "$GITHUB_WORKSPACE/apktool-bin" >> $GITHUB_PATH
          
          # Verify setup
          ls -la apktool-bin/
          echo "Apktool downloaded and configured in PATH"

      - name: Download Samsung framework
        run: |
          echo "Downloading Samsung dm2q framework..."
          curl -L -o framework-dm2q.apk "https://gitlab.com/Eduardob3677/samsung_dm2q_dump/-/raw/dm2qxxx-user-16-BP2A.250605.031.A3-S916BXXS8EYK2-release-keys/system/system/framework/framework-res.apk"
          if [ ! -f framework-dm2q.apk ]; then
            echo "Error: Failed to download framework"
            exit 1
          fi
          echo "Framework downloaded successfully"
          ls -lh framework-dm2q.apk

      - name: Install framework with dm2q tag
        run: |
          echo "Creating framework directory..."
          mkdir -p apktool-frameworks
          echo "Installing framework with tag dm2q to apktool-frameworks..."
          apktool if framework-dm2q.apk -t dm2q -p apktool-frameworks
          echo "Framework installed successfully with tag dm2q"

      - name: Download APK
        run: |
          echo "Downloading APK from ${{ github.event.inputs.apk_url }}"
          curl -L -o app.apk "${{ github.event.inputs.apk_url }}"
          if [ ! -f app.apk ]; then
            echo "Error: Failed to download APK"
            exit 1
          fi
          echo "APK downloaded successfully"
          ls -lh app.apk

      - name: Extract DEX files from APK
        run: |
          echo "Extracting DEX files from APK..."
          apktool d --no-src --keep-broken-res -t dm2q -p apktool-frameworks -o dex-files app.apk

      - name: Install dex2jar
        run: |
          echo "Installing dex2jar..."
          wget -q https://github.com/pxb1988/dex2jar/releases/download/v2.4/dex-tools-v2.4.zip
          unzip -q dex-tools-v2.4.zip
          chmod +x dex-tools-v2.4/*.sh
          echo "$GITHUB_WORKSPACE/dex-tools-v2.4" >> $GITHUB_PATH
          echo "dex2jar installed successfully"

      - name: Install jadx
        run: |
          echo "Installing jadx..."
          wget -q https://github.com/skylot/jadx/releases/download/v1.5.3/jadx-1.5.3.zip
          unzip -q jadx-1.5.3.zip -d jadx
          chmod +x jadx/bin/jadx
          echo "$GITHUB_WORKSPACE/jadx/bin" >> $GITHUB_PATH
          echo "jadx installed successfully"

      - name: Install baksmali/smali
        run: |
          echo "Installing baksmali and smali..."
          mkdir -p smali-tools
          wget -q https://github.com/baksmali/smali/releases/download/3.0.9/smali-baksmali-3.0.9.jar -O smali-tools/baksmali.jar
          wget -q https://github.com/baksmali/smali/releases/download/3.0.9/smali-3.0.9.jar -O smali-tools/smali.jar
          echo "baksmali and smali installed successfully"

      - name: Install Androguard
        run: |
          echo "Installing Androguard..."
          pip install --quiet androguard
          echo "Androguard installed successfully"

      - name: Install binutils and analysis tools for .so files
        run: |
          echo "Installing binutils and analysis tools..."
          sudo apt-get update -qq
          sudo apt-get install -y binutils file
          echo "binutils and analysis tools installed successfully"

      - name: Install radare2 for binary analysis
        run: |
          echo "Installing radare2..."
          sudo apt-get install -y radare2
          echo "radare2 installed successfully"

      - name: Install simplify for DEX deobfuscation
        run: |
          echo "Installing simplify..."
          wget -q https://github.com/CalebFenton/simplify/releases/download/v1.2.1/simplify.jar -O simplify.jar
          echo "simplify installed successfully"

      - name: Install dex-oracle for DEX analysis
        run: |
          echo "Installing dex-oracle..."
          # dex-oracle is a Python-based tool
          pip install --quiet frida-tools
          echo "dex-oracle dependencies installed successfully"

      - name: Install APKiD for DEX protection detection
        run: |
          echo "Installing APKiD..."
          pip install --quiet apkid
          echo "APKiD installed successfully"

      - name: Install additional DEX deobfuscation tools
        run: |
          echo "Installing additional DEX deobfuscation tools..."
          
          # Install Dedexer for DEX analysis with verification
          wget -q https://sourceforge.net/projects/dedexer/files/dedexer/dedexer-2.3.jar/download -O dedexer.jar
          if [ ! -f dedexer.jar ] || [ ! -s dedexer.jar ]; then
            echo "Warning: Dedexer download failed or file is empty"
          else
            echo "Dedexer downloaded successfully"
          fi
          
          # Install LIEF for binary analysis
          pip install --quiet lief pyelftools
          
          echo "Additional DEX deobfuscation tools installed successfully"

      - name: Install DEXDUMP and additional tools
        run: |
          echo "Installing additional Android tools..."
          # Install Android build tools for dexdump
          sudo apt-get update -qq
          sudo apt-get install -y android-sdk-platform-tools-common || echo "Android tools already available"
          
          # Install Ghidra for advanced reverse engineering (headless mode)
          echo "Setting up Ghidra..."
          wget -q https://github.com/NationalSecurityAgency/ghidra/releases/download/Ghidra_11.0_build/ghidra_11.0_PUBLIC_20231222.zip -O ghidra.zip || echo "Ghidra download skipped"
          if [ -f ghidra.zip ]; then
            unzip -q ghidra.zip -d ghidra-install || echo "Ghidra extraction had issues"
            rm ghidra.zip
          fi
          
          echo "Additional tools installed successfully"

      - name: Install IDA Free and analysis tools
        run: |
          echo "Installing binary analysis tools..."
          
          # Install Rizin (fork of radare2 with better maintenance)
          pip install --quiet rzpipe
          
          # Install Capstone disassembly framework
          pip install --quiet capstone unicorn keystone-engine
          
          # Install additional DEX tools
          pip install --quiet pydex python-magic-bin
          
          echo "Binary analysis tools installed successfully"

      - name: Run dex2jar
        run: |
          echo "Converting DEX files to JAR with dex2jar..."
          mkdir -p dex2jar-output
          if [ -f dex-files/classes.dex ]; then
            d2j-dex2jar.sh dex-files/classes.dex -o dex2jar-output/classes.jar --force || echo "dex2jar conversion had warnings"
          fi
          # Convert additional dex files if they exist
          for dex_file in dex-files/classes*.dex; do
            if [ -f "$dex_file" ] && [ "$dex_file" != "dex-files/classes.dex" ]; then
              basename=$(basename "$dex_file" .dex)
              d2j-dex2jar.sh "$dex_file" -o "dex2jar-output/${basename}.jar" --force || echo "dex2jar conversion had warnings"
            fi
          done
          echo "dex2jar conversion completed"
          ls -lh dex2jar-output/ || echo "No JAR files generated"

      - name: Run jadx
        run: |
          echo "Decompiling APK to Java source with jadx..."
          mkdir -p jadx-output
          jadx app.apk -d jadx-output --show-bad-code || echo "jadx decompilation completed with warnings"
          echo "jadx decompilation completed"
          ls -lh jadx-output/ || echo "No output generated"

      - name: Run baksmali
        run: |
          echo "Disassembling DEX files with baksmali..."
          mkdir -p baksmali-output
          for dex_file in dex-files/*.dex; do
            if [ -f "$dex_file" ]; then
              basename=$(basename "$dex_file" .dex)
              java -jar smali-tools/baksmali.jar d "$dex_file" -o "baksmali-output/${basename}" || echo "baksmali disassembly had warnings"
            fi
          done
          echo "baksmali disassembly completed"
          ls -lh baksmali-output/ || echo "No output generated"

      - name: Run Androguard analysis
        run: |
          echo "Analyzing APK with Androguard..."
          mkdir -p androguard-output
          python3 << 'EOF'
          from androguard.core.apk import APK
          from androguard.core.dex import DEX
          import json
          import sys
          import os
          
          try:
              # Analyze APK
              apk = APK("app.apk")
              
              # Extract basic information
              info = {
                  "package": apk.get_package(),
                  "app_name": apk.get_app_name(),
                  "version_name": apk.get_androidversion_name(),
                  "version_code": apk.get_androidversion_code(),
                  "min_sdk": apk.get_min_sdk_version(),
                  "target_sdk": apk.get_target_sdk_version(),
                  "permissions": apk.get_permissions(),
                  "activities": apk.get_activities(),
                  "services": apk.get_services(),
                  "receivers": apk.get_receivers(),
                  "providers": apk.get_providers(),
              }
              
              # Save to JSON
              with open("androguard-output/apk_analysis.json", "w") as f:
                  json.dump(info, f, indent=2)
              
              # Analyze DEX files
              if not os.path.exists("dex-files"):
                  print("Warning: dex-files directory does not exist")
              else:
                  dex_files = os.listdir("dex-files")
                  dex_info = []
                  
                  # Load DEX files once and reuse objects
                  dex_objects = {}
                  for dex_file in dex_files:
                      if dex_file.endswith('.dex'):
                          dex_path = os.path.join("dex-files", dex_file)
                          with open(dex_path, 'rb') as f:
                              d = DEX(f.read())
                          dex_objects[dex_file] = d
                          dex_info.append({
                              "file": dex_file,
                              "classes_count": len(list(d.get_classes())),
                              "methods_count": len(list(d.get_methods())),
                              "strings_count": len(list(d.get_strings()))
                          })
                  
                  with open("androguard-output/dex_analysis.json", "w") as f:
                      json.dump(dex_info, f, indent=2)
                  
                  # Extract class names using cached DEX objects
                  with open("androguard-output/classes.txt", "w") as f:
                      for dex_file, d in dex_objects.items():
                          f.write(f"\n=== {dex_file} ===\n")
                          for cls in d.get_classes():
                              f.write(f"{cls.get_name()}\n")
              
              print("Androguard analysis completed successfully")
              
          except Exception as e:
              print(f"Androguard analysis failed: {e}", file=sys.stderr)
              sys.exit(1)
          EOF
          
          echo "Androguard analysis completed"
          ls -lh androguard-output/

      - name: Run APKiD for protection detection
        run: |
          echo "Detecting DEX protections with APKiD..."
          mkdir -p apkid-output
          apkid app.apk -o apkid-output/apkid_analysis.json || echo "APKiD analysis completed with warnings"
          if [ -f apkid-output/apkid_analysis.json ]; then
            cat apkid-output/apkid_analysis.json
          fi
          echo "APKiD analysis completed"

      - name: Run simplify for DEX deobfuscation
        run: |
          echo "Running simplify on DEX files for deobfuscation..."
          mkdir -p simplify-output
          for dex_file in dex-files/*.dex; do
            if [ -f "$dex_file" ]; then
              basename=$(basename "$dex_file" .dex)
              echo "Simplifying $dex_file..."
              java -jar simplify.jar -i "$dex_file" -o "simplify-output/${basename}_simplified.dex" || echo "Simplify completed with warnings for $dex_file"
            fi
          done
          echo "Simplify deobfuscation completed"
          ls -lh simplify-output/ || echo "No output generated"

      - name: Run Dedexer for additional DEX analysis
        run: |
          echo "Running Dedexer on DEX files..."
          mkdir -p dedexer-output
          for dex_file in dex-files/*.dex; do
            if [ -f "$dex_file" ]; then
              basename=$(basename "$dex_file" .dex)
              echo "Analyzing $dex_file with Dedexer..."
              java -jar dedexer.jar -d "dedexer-output/${basename}" "$dex_file" || echo "Dedexer analysis completed with warnings for $dex_file"
            fi
          done
          echo "Dedexer analysis completed"
          ls -lh dedexer-output/ || echo "No output generated"

      - name: Analyze native libraries with LIEF
        run: |
          echo "Analyzing native libraries with LIEF..."
          mkdir -p lief-analysis
          
          # Extract lib folder if not already extracted
          if [ ! -d so-extraction/lib ]; then
            unzip -q app.apk "lib/*" -d so-extraction || echo "No lib folder found"
          fi
          
          if [ -d so-extraction/lib ]; then
            echo "Running LIEF analysis on native libraries..."
            
            python3 << 'EOF'
          import lief
          import os
          import json
          
          # Constants for limiting output size
          MAX_FUNCTIONS_PER_BINARY = 100  # Limit functions to prevent huge JSON files
          
          results = {}
          
          if os.path.exists("so-extraction/lib"):
              for root, dirs, files in os.walk("so-extraction/lib"):
                  for file in files:
                      if file.endswith('.so'):
                          so_path = os.path.join(root, file)
                          try:
                              binary = lief.parse(so_path)
                              if binary:
                                  analysis = {
                                      'file': file,
                                      'format': str(binary.format),
                                      'architecture': str(binary.header.machine_type) if hasattr(binary, 'header') else 'unknown',
                                      'entry_point': hex(binary.entrypoint) if hasattr(binary, 'entrypoint') else 'N/A',
                                      'libraries': [lib.name for lib in binary.libraries] if hasattr(binary, 'libraries') else [],
                                      'exported_functions': [],
                                      'imported_functions': [],
                                      'sections': []
                                  }
                                  
                                  # Get exported functions (limited to prevent huge output)
                                  if hasattr(binary, 'exported_functions'):
                                      analysis['exported_functions'] = [f.name for f in binary.exported_functions[:MAX_FUNCTIONS_PER_BINARY]]
                                      if len(binary.exported_functions) > MAX_FUNCTIONS_PER_BINARY:
                                          analysis['exported_functions_truncated'] = f"Showing {MAX_FUNCTIONS_PER_BINARY} of {len(binary.exported_functions)}"
                                  
                                  # Get imported functions (limited to prevent huge output)
                                  if hasattr(binary, 'imported_functions'):
                                      analysis['imported_functions'] = [f.name for f in binary.imported_functions[:MAX_FUNCTIONS_PER_BINARY]]
                                      if len(binary.imported_functions) > MAX_FUNCTIONS_PER_BINARY:
                                          analysis['imported_functions_truncated'] = f"Showing {MAX_FUNCTIONS_PER_BINARY} of {len(binary.imported_functions)}"
                                  
                                  # Get sections
                                  if hasattr(binary, 'sections'):
                                      for section in binary.sections:
                                          analysis['sections'].append({
                                              'name': section.name,
                                              'size': section.size,
                                              'virtual_address': hex(section.virtual_address) if hasattr(section, 'virtual_address') else 'N/A'
                                          })
                                  
                                  results[file] = analysis
                                  print(f"Analyzed: {file}")
                          except Exception as e:
                              print(f"Error analyzing {file}: {e}")
                              results[file] = {'error': str(e)}
          
          with open("lief-analysis/analysis.json", "w") as f:
              json.dump(results, f, indent=2)
          
          print(f"LIEF analysis completed. Analyzed {len(results)} files.")
          EOF
            
            echo "LIEF analysis completed"
            ls -lh lief-analysis/
          else
            echo "No native libraries found for LIEF analysis"
          fi

      - name: Advanced DEX decryption and unpacking analysis
        run: |
          echo "Performing advanced DEX decryption analysis..."
          mkdir -p decryption-analysis
          
          python3 << 'EOF'
          import os
          import json
          import struct
          
          def analyze_dex_encryption(dex_path):
              """Analyze DEX file for encryption/packing"""
              analysis = {
                  'file': os.path.basename(dex_path),
                  'encrypted': False,
                  'suspicious_sections': [],
                  'entropy_high': False,
                  'custom_loader': False
              }
              
              try:
                  with open(dex_path, 'rb') as f:
                      # Read DEX header
                      magic = f.read(8)
                      
                      # Check if it's a valid DEX file
                      if not magic.startswith(b'dex\n'):
                          analysis['suspicious_sections'].append('Invalid DEX magic - possibly encrypted')
                          analysis['encrypted'] = True
                          return analysis
                      
                      # Read file size
                      f.seek(32)
                      file_size = struct.unpack('<I', f.read(4))[0]
                      
                      # Read data section
                      f.seek(108)
                      data_size = struct.unpack('<I', f.read(4))[0]
                      
                      # Check for unusual size ratios (indicator of packing)
                      if file_size > 0 and data_size / file_size > 0.8:
                          analysis['suspicious_sections'].append('High data-to-file ratio - possible packing')
                      
                      # Read some data to check entropy
                      f.seek(0)
                      sample_data = f.read(min(10000, file_size))
                      
                      # Simple entropy check (count unique bytes)
                      unique_bytes = len(set(sample_data))
                      if unique_bytes > 240:  # High entropy
                          analysis['entropy_high'] = True
                          analysis['suspicious_sections'].append('High entropy detected - possible encryption')
                      
                      # Look for custom loader indicators
                      f.seek(0)
                      content = f.read()
                      
                      loader_patterns = [
                          b'StubApplication',
                          b'ProxyApplication', 
                          b'MultiDex',
                          b'attachBaseContext',
                          b'DexClassLoader',
                          b'loadDex'
                      ]
                      
                      for pattern in loader_patterns:
                          if pattern in content:
                              analysis['custom_loader'] = True
                              analysis['suspicious_sections'].append(f'Custom loader pattern found: {pattern.decode("utf-8", errors="ignore")}')
                      
                      # Check if likely encrypted
                      if analysis['entropy_high'] or analysis['custom_loader']:
                          analysis['encrypted'] = True
                  
                  return analysis
                  
              except Exception as e:
                  return {'file': os.path.basename(dex_path), 'error': str(e)}
          
          results = []
          
          if os.path.exists("dex-files"):
              for dex_file in os.listdir("dex-files"):
                  if dex_file.endswith('.dex'):
                      dex_path = os.path.join("dex-files", dex_file)
                      analysis = analyze_dex_encryption(dex_path)
                      results.append(analysis)
                      print(f"Analyzed {dex_file}: Encrypted={analysis.get('encrypted', False)}")
          
          with open("decryption-analysis/dex_encryption_analysis.json", "w") as f:
              json.dump(results, f, indent=2)
          
          # Create readable report
          with open("decryption-analysis/encryption_report.txt", "w") as f:
              f.write("=== DEX Encryption Analysis Report ===\n\n")
              for result in results:
                  f.write(f"File: {result.get('file', 'unknown')}\n")
                  f.write(f"Likely Encrypted: {result.get('encrypted', False)}\n")
                  f.write(f"High Entropy: {result.get('entropy_high', False)}\n")
                  f.write(f"Custom Loader Detected: {result.get('custom_loader', False)}\n")
                  if result.get('suspicious_sections'):
                      f.write("Suspicious Indicators:\n")
                      for indicator in result['suspicious_sections']:
                          f.write(f"  - {indicator}\n")
                  f.write("\n" + "="*50 + "\n\n")
          
          print("DEX decryption analysis completed")
          EOF
          
          echo "DEX decryption analysis completed"
          ls -lh decryption-analysis/

      - name: Analyze .so files
        run: |
          echo "Analyzing .so files in APK..."
          mkdir -p so-analysis
          
          # Extract lib folder if it exists in the apk
          unzip -q app.apk "lib/*" -d so-extraction || echo "No lib folder found or extraction had issues"
          
          if [ -d so-extraction/lib ]; then
            echo "Found native libraries, analyzing..."
            
            # Analyze each .so file
            for so_file in $(find so-extraction/lib -name "*.so"); do
              echo "Analyzing: $so_file" | tee -a so-analysis/analysis.txt
              basename=$(basename "$so_file")
              
              # File type information
              echo "=== File Info: $basename ===" | tee -a so-analysis/analysis.txt
              file "$so_file" | tee -a so-analysis/analysis.txt
              
              # Extract strings
              echo "=== Strings in $basename ===" > "so-analysis/${basename}_strings.txt"
              strings "$so_file" >> "so-analysis/${basename}_strings.txt" 2>&1 || echo "Could not extract strings"
              
              # Get symbols
              echo "=== Symbols in $basename ===" > "so-analysis/${basename}_symbols.txt"
              nm "$so_file" >> "so-analysis/${basename}_symbols.txt" 2>&1 || echo "Could not extract symbols"
              
              # Get section headers
              echo "=== Section Headers in $basename ===" > "so-analysis/${basename}_sections.txt"
              objdump -h "$so_file" >> "so-analysis/${basename}_sections.txt" 2>&1 || echo "Could not extract section headers"
              
              # Radare2 basic analysis
              echo "=== Radare2 Info for $basename ===" > "so-analysis/${basename}_r2info.txt"
              r2 -q -c "i" "$so_file" >> "so-analysis/${basename}_r2info.txt" 2>&1 || echo "Could not run radare2 analysis"
              
            done
            
            echo "Native library analysis completed"
            ls -lh so-analysis/
          else
            echo "No native libraries found in APK"
          fi

      - name: Extract and analyze encryption patterns
        run: |
          echo "Analyzing encryption patterns in DEX files..."
          mkdir -p crypto-analysis
          
          python3 << 'EOF'
          import os
          import json
          
          crypto_patterns = {
              "AES": [b"Ljavax/crypto/Cipher;", b"AES", b"aes"],
              "DES": [b"DES", b"TripleDES", b"des"],
              "RSA": [b"RSA", b"Ljavax/crypto/", b"rsa"],
              "Base64": [b"Landroid/util/Base64;", b"base64", b"Base64"],
              "Custom_XOR": [b"xor", b"XOR"],
              "Obfuscation": [b"ProGuard", b"DexGuard", b"Allatori"]
          }
          
          results = {}
          
          if os.path.exists("dex-files"):
              for dex_file in os.listdir("dex-files"):
                  if dex_file.endswith('.dex'):
                      dex_path = os.path.join("dex-files", dex_file)
                      file_size = os.path.getsize(dex_path)
                      
                      # Skip files larger than 100MB to avoid memory issues
                      if file_size > 100 * 1024 * 1024:
                          print(f"Skipping {dex_file} (too large: {file_size / 1024 / 1024:.1f}MB)")
                          continue
                      
                      with open(dex_path, 'rb') as f:
                          content = f.read()
                      
                      file_results = {}
                      for crypto_type, patterns in crypto_patterns.items():
                          matches = 0
                          for pattern in patterns:
                              matches += content.count(pattern)
                          if matches > 0:
                              file_results[crypto_type] = matches
                      
                      if file_results:
                          results[dex_file] = file_results
          
          with open("crypto-analysis/encryption_patterns.json", "w") as f:
              json.dump(results, f, indent=2)
          
          print("Encryption pattern analysis completed")
          print(json.dumps(results, indent=2))
          EOF
          
          echo "Crypto analysis completed"
          ls -lh crypto-analysis/

      - name: Decompile APK
        run: |
          echo "Decompiling APK with dm2q framework..."
          # Build apktool command with optional parameters using array
          # Note: --no-debug-info is controlled by keep_debug_info input
          CMD=(apktool d -o apktool -t dm2q -p apktool-frameworks)
          
          # Check mutual exclusivity of quiet and verbose flags
          if [ "${{ github.event.inputs.quiet }}" = "true" ] && [ "${{ github.event.inputs.verbose }}" = "true" ]; then
            echo "Error: quiet and verbose flags are mutually exclusive"
            exit 1
          fi
          
          # Add optional quiet flag
          if [ "${{ github.event.inputs.quiet }}" = "true" ]; then
            CMD+=(-q)
            echo "Using quiet mode (-q)"
          fi
          
          # Add optional verbose flag
          if [ "${{ github.event.inputs.verbose }}" = "true" ]; then
            CMD+=(-v)
            echo "Using verbose mode (-v)"
          fi
          
          # Add optional force flag
          if [ "${{ github.event.inputs.force }}" = "true" ]; then
            CMD+=(-f)
            echo "Using force mode (-f)"
          fi
          
          # Add optional jobs parameter with validation
          if [ -n "${{ github.event.inputs.jobs }}" ]; then
            # Validate that jobs is a non-negative integer (0 means auto-detect)
            if ! [[ "${{ github.event.inputs.jobs }}" =~ ^[0-9]+$ ]]; then
              echo "Error: jobs must be a non-negative integer (0 for auto-detect)"
              exit 1
            fi
            CMD+=(-j "${{ github.event.inputs.jobs }}")
            if [ "${{ github.event.inputs.jobs }}" = "0" ]; then
              echo "Using auto-detect for parallel jobs"
            else
              echo "Using ${{ github.event.inputs.jobs }} parallel jobs"
            fi
          fi
          
          # Add optional lib parameter (can be multiple, comma-separated) with validation
          if [ -n "${{ github.event.inputs.lib }}" ]; then
            IFS=',' read -ra LIBS <<< "${{ github.event.inputs.lib }}"
            for lib in "${LIBS[@]}"; do
              # Trim whitespace
              lib=$(echo "$lib" | xargs)
              # Validate format: package:file and prevent path traversal
              if ! [[ "$lib" =~ ^[a-zA-Z0-9._-]+:[a-zA-Z0-9._/-]+$ ]]; then
                echo "Error: lib format must be package:file (got: $lib)"
                exit 1
              fi
              # Check for path traversal sequences
              if [[ "$lib" == *".."* ]]; then
                echo "Error: lib path cannot contain '..' sequences"
                exit 1
              fi
              CMD+=(-l "$lib")
              echo "Using shared library: $lib"
            done
          fi
          
          # Add optional no-resources flag
          if [ "${{ github.event.inputs.no_res }}" = "true" ]; then
            CMD+=(-r)
            echo "Skipping resource decoding (-r)"
          fi
          
          # Add optional no-sources flag
          if [ "${{ github.event.inputs.no_src }}" = "true" ]; then
            CMD+=(-s)
            echo "Skipping source decoding (-s)"
          fi
          
          # Add optional only-main-classes flag
          if [ "${{ github.event.inputs.only_main_classes }}" = "true" ]; then
            if [ "${{ github.event.inputs.no_src }}" = "true" ]; then
              echo "Error: only-main-classes conflicts with no-src"
              exit 1
            fi
            CMD+=(--only-main-classes)
            echo "Only disassembling main dex classes (--only-main-classes)"
          fi
          
          # Add no-debug-info flag (default behavior unless keep_debug_info is true)
          if [ "${{ github.event.inputs.keep_debug_info }}" != "true" ]; then
            CMD+=(--no-debug-info)
            echo "Excluding debug info from sources (--no-debug-info)"
          else
            echo "Keeping debug info in sources"
          fi
          
          # Add optional only-manifest flag
          if [ "${{ github.event.inputs.only_manifest }}" = "true" ]; then
            if [ "${{ github.event.inputs.no_res }}" = "true" ]; then
              echo "Error: only-manifest conflicts with no-res"
              exit 1
            fi
            CMD+=(--only-manifest)
            echo "Only decoding AndroidManifest.xml (--only-manifest)"
          fi
          
          # Add optional res-resolve-mode
          if [ -n "${{ github.event.inputs.res_resolve_mode }}" ]; then
            if [ "${{ github.event.inputs.no_res }}" = "true" ]; then
              echo "Error: res-resolve-mode conflicts with no-res"
              exit 1
            fi
            if [ "${{ github.event.inputs.only_manifest }}" = "true" ]; then
              echo "Error: res-resolve-mode conflicts with only-manifest"
              exit 1
            fi
            # Validate res_resolve_mode value
            case "${{ github.event.inputs.res_resolve_mode }}" in
              remove|dummy|keep)
                CMD+=(--res-resolve-mode "${{ github.event.inputs.res_resolve_mode }}")
                echo "Using resource resolve mode: ${{ github.event.inputs.res_resolve_mode }}"
                ;;
              *)
                echo "Error: Invalid res-resolve-mode. Must be 'remove', 'dummy', or 'keep'"
                exit 1
                ;;
            esac
          fi
          
          # Add optional keep-broken-res flag
          if [ "${{ github.event.inputs.keep_broken_res }}" = "true" ]; then
            if [ "${{ github.event.inputs.no_res }}" = "true" ]; then
              echo "Error: keep-broken-res conflicts with no-res"
              exit 1
            fi
            if [ "${{ github.event.inputs.only_manifest }}" = "true" ]; then
              echo "Error: keep-broken-res conflicts with only-manifest"
              exit 1
            fi
            CMD+=(--keep-broken-res)
            echo "Keeping broken resources (--keep-broken-res)"
          fi
          
          # Add optional match-original flag
          if [ "${{ github.event.inputs.match_original }}" = "true" ]; then
            CMD+=(--match-original)
            echo "Keeping files closest to original (--match-original)"
          fi
          
          # Add optional no-assets flag
          if [ "${{ github.event.inputs.no_assets }}" = "true" ]; then
            CMD+=(--no-assets)
            echo "Skipping asset decoding (--no-assets)"
          fi
          
          # Add APK file at the end
          CMD+=(app.apk)
          
          echo "Executing: ${CMD[@]}"
          "${CMD[@]}"
          
          if [ ! -d apktool ]; then
            echo "Error: Decompilation failed"
            exit 1
          fi
          echo "Decompilation completed successfully"

      - name: Extract package name
        id: package-name
        run: |
          # Extract package name from AndroidManifest.xml
          if [ -f apktool/AndroidManifest.xml ]; then
            PACKAGE=$(grep -oP 'package="\K[^"]+' apktool/AndroidManifest.xml | head -n 1)
            if [ -z "$PACKAGE" ]; then
              echo "Error: Could not extract package name"
              exit 1
            fi
            # Replace dots with underscores
            REPO_NAME=$(echo "$PACKAGE" | tr '.' '_')
            echo "package=$PACKAGE" >> $GITHUB_OUTPUT
            echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
            echo "Package: $PACKAGE"
            echo "Repository name: $REPO_NAME"
          else
            echo "Error: AndroidManifest.xml not found"
            exit 1
          fi

      - name: Check and create repository
        id: create-repo
        env:
          GH_TOKEN: ${{ secrets.TEST }}
          TARGET_USER: ${{ github.event.inputs.target_username }}
          BASE_REPO_NAME: ${{ steps.package-name.outputs.repo_name }}
        run: |
          REPO_NAME="$BASE_REPO_NAME"
          COUNTER=2

          # Check if repository exists and find available name
          while gh repo view "$TARGET_USER/$REPO_NAME" &>/dev/null; do
            echo "Repository $TARGET_USER/$REPO_NAME already exists"
            REPO_NAME="${BASE_REPO_NAME}_${COUNTER}"
            COUNTER=$((COUNTER + 1))
          done

          echo "Creating repository: $TARGET_USER/$REPO_NAME"
          gh repo create "$TARGET_USER/$REPO_NAME" --public --description "Decompiled APK: ${{ steps.package-name.outputs.package }}"

          echo "final_repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "Repository created: $TARGET_USER/$REPO_NAME"

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install Git LFS
        run: |
          # Install Git LFS (should already be available on ubuntu-latest)
          git lfs version || (sudo apt-get update && sudo apt-get install -y git-lfs)
          echo "Git LFS installed successfully"

      - name: Prepare output directory
        run: |
          echo "Creating output directory and organizing analysis results..."
          mkdir -p out
          
          # Copy all analysis outputs to the out directory
          echo "Copying apktool decompilation output..."
          cp -r apktool out/ || echo "apktool directory not found"
          
          echo "Copying DEX analysis outputs..."
          cp -r dex-files out/ || echo "dex-files not found"
          cp -r dex2jar-output out/ || echo "dex2jar-output not found"
          cp -r jadx-output out/ || echo "jadx-output not found"
          cp -r baksmali-output out/ || echo "baksmali-output not found"
          cp -r androguard-output out/ || echo "androguard-output not found"
          cp -r apkid-output out/ || echo "apkid-output not found"
          cp -r simplify-output out/ || echo "simplify-output not found"
          cp -r dedexer-output out/ || echo "dedexer-output not found"
          
          echo "Copying native library and security analysis outputs..."
          cp -r so-analysis out/ || echo "so-analysis not found"
          cp -r crypto-analysis out/ || echo "crypto-analysis not found"
          cp -r lief-analysis out/ || echo "lief-analysis not found"
          cp -r decryption-analysis out/ || echo "decryption-analysis not found"
          
          echo "Output directory prepared successfully"
          ls -la out/

      - name: Track large files with Git LFS
        run: |
          cd out
          
          # Initialize git repository first (needed for git lfs)
          git init
          
          # Initialize Git LFS
          git lfs install
          
          # Find files larger than 99MB and track them with Git LFS
          echo "Scanning for files larger than 99MB..."
          LARGE_FILES_FOUND=false
          
          # Find files larger than 99MB (99 * 1024 * 1024 bytes = 103,809,024 bytes = 99 MiB)
          # Using MiB (binary) threshold to stay safely under GitHub's 100MB limit
          while IFS= read -r -d '' file; do
            if [ -f "$file" ]; then
              size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
              if [ "$size" -gt 103809024 ]; then
                LARGE_FILES_FOUND=true
                # Calculate size in MB for display (without bc dependency)
                size_mb=$((size / 1024 / 1024))
                echo "Found large file: $file (${size_mb}MB)"
                
                # Track this file pattern with git lfs
                git lfs track "$file"
              fi
            fi
          done < <(find . -type f -print0)
          
          if [ "$LARGE_FILES_FOUND" = true ]; then
            echo "✅ Large files tracked with Git LFS"
            echo "Git LFS tracking patterns:"
            cat .gitattributes
          else
            echo "ℹ️  No files larger than 99MB found"
          fi

      - name: Push decompiled content to new repository
        env:
          GH_TOKEN: ${{ secrets.TEST }}
          TARGET_USER: ${{ github.event.inputs.target_username }}
          REPO_NAME: ${{ steps.create-repo.outputs.final_repo_name }}
        run: |
          cd out
          
          # Add all files (git lfs will handle large files automatically)
          git add .
          
          # Commit with information about large files if any
          if [ -f .gitattributes ]; then
            git commit -m "Initial commit: Decompiled APK (${{ steps.package-name.outputs.package }})" \
                       -m "Large files tracked with Git LFS (see .gitattributes)" \
                       -m "Includes comprehensive DEX analysis: dex2jar, jadx, baksmali, Androguard, simplify, APKiD, Dedexer" \
                       -m "Includes native library analysis with LIEF, radare2, binutils, and advanced DEX decryption analysis"
          else
            git commit -m "Initial commit: Decompiled APK (${{ steps.package-name.outputs.package }})" \
                       -m "Includes comprehensive DEX analysis: dex2jar, jadx, baksmali, Androguard, simplify, APKiD, Dedexer" \
                       -m "Includes native library analysis with LIEF, radare2, binutils, and advanced DEX decryption analysis"
          fi
          
          # Configure remote and push
          git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/$TARGET_USER/$REPO_NAME.git"
          git branch -M main
          
          # Push to remote (Git LFS pre-push hook will automatically handle LFS files)
          echo "Pushing content to repository..."
          git push -u origin main

          echo "✅ Decompiled content pushed successfully to: https://github.com/$TARGET_USER/$REPO_NAME"

      - name: Summary
        run: |
          echo "## Decompilation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Package**: ${{ steps.package-name.outputs.package }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: [${{ github.event.inputs.target_username }}/${{ steps.create-repo.outputs.final_repo_name }}](https://github.com/${{ github.event.inputs.target_username }}/${{ steps.create-repo.outputs.final_repo_name }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Directory Structure" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All analysis outputs are organized in the repository root:" >> $GITHUB_STEP_SUMMARY
          echo "- \`apktool/\` - Main APK decompilation (resources, smali, manifest, etc.)" >> $GITHUB_STEP_SUMMARY
          echo "- \`dex-files/\` - Extracted DEX files" >> $GITHUB_STEP_SUMMARY
          echo "- \`dex2jar-output/\` - DEX to JAR conversions" >> $GITHUB_STEP_SUMMARY
          echo "- \`jadx-output/\` - Java source code decompilation" >> $GITHUB_STEP_SUMMARY
          echo "- \`baksmali-output/\` - Smali disassembly" >> $GITHUB_STEP_SUMMARY
          echo "- \`androguard-output/\` - APK analysis JSON reports" >> $GITHUB_STEP_SUMMARY
          echo "- \`apkid-output/\` - Protection detection reports" >> $GITHUB_STEP_SUMMARY
          echo "- \`simplify-output/\` - Deobfuscated DEX files" >> $GITHUB_STEP_SUMMARY
          echo "- \`dedexer-output/\` - Dedexer DEX analysis" >> $GITHUB_STEP_SUMMARY
          echo "- \`so-analysis/\` - Native library analysis" >> $GITHUB_STEP_SUMMARY
          echo "- \`crypto-analysis/\` - Encryption pattern detection" >> $GITHUB_STEP_SUMMARY
          echo "- \`lief-analysis/\` - LIEF binary analysis of native libraries" >> $GITHUB_STEP_SUMMARY
          echo "- \`decryption-analysis/\` - Advanced DEX decryption analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### DEX Analysis Tools Used" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **apktool**: APK decompilation (output in \`apktool/\` directory)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **dex2jar**: DEX to JAR conversion (output in \`dex2jar-output/\`)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **jadx**: Java decompilation (output in \`jadx-output/\`)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **baksmali**: DEX disassembly (output in \`baksmali-output/\`)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **Androguard**: APK analysis (output in \`androguard-output/\`)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **APKiD**: Protection detection (output in \`apkid-output/\`)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **simplify**: DEX deobfuscation (output in \`simplify-output/\`)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **Dedexer**: Additional DEX analysis (output in \`dedexer-output/\`)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Native Library Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **binutils** (strings, nm, objdump): Binary analysis" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **radare2**: Advanced binary analysis (output in \`so-analysis/\`)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **LIEF**: Advanced binary analysis of native libraries (output in \`lief-analysis/\`)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Security & Deobfuscation Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **Crypto pattern detection**: Encryption/obfuscation analysis (output in \`crypto-analysis/\`)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ **DEX decryption analyzer**: Advanced encryption detection (output in \`decryption-analysis/\`)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Decompilation completed successfully!" >> $GITHUB_STEP_SUMMARY
